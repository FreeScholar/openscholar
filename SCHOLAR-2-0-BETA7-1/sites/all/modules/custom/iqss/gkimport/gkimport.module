<?php

include_once('gkimport.drush.inc');
include_once('gkimport.settings.inc');
include_once('gkimport.utils.inc');

define(GKIMPORT_FS_PATH,  '/nfs/www/edu-harvard-iq-scholar-dev3'); //file system path to drupal root (NO TRAILING SLASH)
define(GKIMPORT_DOWNLOAD, FALSE);  // TRUE tells module to download files with wget, otherwise assumes files stored locally

/**
 * Begins import process
  */
function gkimport_import($drush_run = 0){
  define(GKIMPORT_DRUSH_RUN, $drush_run);
  $mode = (GKIMPORT_DOWNLOAD) ? 'TRUE' : 'FALSE';
  drush_print("Download mode is set to $mode");
  drush_print("Begining import...");
  
/*  $module_list = array('iqss_gking', 'iqss_rbuild', 'dialog', 'twitter_pull');
  gkimport_enable_modules($module_list);*/

  gkimport_create_site();
  gkimport_parse_files();
  gkimport_update_notes();
  gkimport_software_pubs_set();
  gkimport_data_pubs_set();
  gkimport_upload_pdfs();
  gkimport_update_aliases();
  gkimport_import_bio();
  gkimport_import_contact_page();
  gkimport_import_links();
  gkimport_import_classes();
  gkimport_assign_theme(); 
  gkimport_save_site_layout($drush_run);
  gkimport_save_sample_pages();

  $message = 'Import part 1 completed';
  $complete = ($drush_run  === 1) ?  drush_print(t("$message")) : drupal_set_message(t("$message"));
}

function gkimport_import_2($drush_run = 0){
  drush_print("Begining import, part 2...");

  gkimport_assign_terms();
  gkimport_create_profiles();
  gkimport_cleanup();

  $message = 'Import part 2 completed';
  $complete = ($drush_run  === 1) ?  drush_print(t("$message")) : drupal_set_message(t("$message"));
}

function gkimport_import_3($drush_run = 0){
  drush_print("Begining import, part 3...");

   gkimport_import_presentations();
   //node access check
   gkimport_node_access_check();

  $message = 'Import part 3 completed';
  $complete = ($drush_run  === 1) ?  drush_print(t("$message")) : drupal_set_message(t("$message"));
}


/**
 * Function to create gking user account and web site
 * @return 
 *  If vsite created , then  vsite object, otherwise false
 */
function gkimport_create_site(){ 
  vsite_include('vsiteapi');
  install_include(array('user'));

  //gary's site base info
  $settings = array(
  'name' => 'gking',
  'mail' => 'jweiner@hmdc.harvard.edu', //'king@harvard.edu',
  'pass' => user_password(),
  'roles' => array(variable_get('scholar_manager_role', 'scholar admin')),
  'domain' => 'gking',
  'preset' => variable_get('scholar_default_preset', 'scholar'),
  );

  //if user already exists then skip
  if(db_result(db_query("SELECT name from {users} WHERE name = '%s'", $settings['name']))){
    drupal_set_message(t("A user account already exists for %name", array('%name' => $settings['name'])));
    return FALSE;
  }

  //otherwise create user account/roles/site
  else{
    $rid = array_search(variable_get('scholar_manager_role', 'scholar admin'), user_roles());
    $user = install_add_user($settings['name'], $settings['pass'], $settings['mail'], $settings['roles'], $status = 1);
    if ($user) {
     $mesage = GKIMPORT_DRUSH_RUN === 1 ?  drush_print(t('Created user account: !username', array('!username' => $settings['name']))) : ''; 
    }
    $vsite = vsite_vsite_create($settings['name'], $settings['domain'], $settings['preset']);
    if ($vsite){
      define(GKIMPORT_SID, $vsite -> sid );
      variable_set('gkimport_site_id', $vsite -> sid );
            
      $mesage = GKIMPORT_DRUSH_RUN === 1 ? drush_print(t('Created web site: !domain', array('!domain' => $settings['domain']))) : '';     
      
      //create files directory
      $file_paths = array(
      variable_get('file_directory_path', conf_path() .'/files') . '/gking',
      variable_get('file_directory_path', conf_path() .'/files') . '/gking/files',
      );
      
      foreach($file_paths as $fp){      
      $check = file_check_directory($fp, 1);
      $msg = $check ? "The directory $fp exists" : "ERROR: The directory $fp could not be created";
      drush_print($msg);
      }  
      //now customize the vsite
      gkimport_customize_site($vsite);
    }
  }
}

function  gkimport_customize_site($vsite){
  include_once('includes/install.inc');
  drupal_install_modules(array('scholar_profiles'));
  //update the title
  $node_tables = array('node', 'node_revisions');
  foreach($node_tables as $table){
   db_query("UPDATE { $table } SET title = '%s' WHERE nid = %d", 'Gary King', $vsite -> group -> nid);
  }
  //update the address
  $address = '1737 Cambridge St. Cambridge, MA 02138';
  $sid = $vsite -> group ->nid;
  $vsite -> group -> og_description = "Albert J. Weatherhead III University Professor at Harvard University";
  
  //make sure these features are enabled
  $vsite -> features['scholar_announcements'] = SPACES_OG_PUBLIC;
  $vsite -> features['scholar_biocv'] = SPACES_OG_PUBLIC; 
  $vsite -> features['scholar_classes'] = SPACES_OG_PUBLIC; 
  $vsite -> features['scholar_dvn'] = SPACES_OG_PUBLIC;
  $vsite -> features['scholar_events'] = SPACES_OG_PUBLIC;
  $vsite -> features['scholar_image_gallery'] = SPACES_OG_PUBLIC;
  $vsite -> features['scholar_links'] = SPACES_OG_PUBLIC;
  $vsite -> features['scholar_presentations'] = SPACES_OG_PUBLIC;
  $vsite -> features['scholar_profiles'] = SPACES_OG_PUBLIC;
  $vsite -> features['scholar_publications'] = SPACES_OG_PUBLIC;
  $vsite -> features['scholar_reader'] = SPACES_OG_PUBLIC;
  $vsite -> features['scholar_software'] = SPACES_OG_PUBLIC;
  
  db_query("UPDATE {content_type_vsite} SET field_vsite_address_value = '%s' WHERE nid = %d", $address, $sid);
  //$cid = 'content:' . $sid . ':' . $sid;
  cache_clear_all("content:$sid:$sid", 'cache_content');  
  //save Gary's dvn alias
  $vsite -> settings['scholar_dvn']['dvn_alias'] = 'king';
  spaces_save($vsite);
  gkimport_print("Customized site features and information"); 
  
  //reload the vsite
  $vsite = spaces_load("og", gkimport_get_sid());
  //define custom settings for primary menu links
  $item_settings = array(
  'biocv' => array('weight' => 0, 'primary' => TRUE, 'custom_title' => TRUE, 'title' =>'Bio & C.V.'),
  'publications' =>array('weight' => 1, 'primary' => TRUE,  'custom_title' => TRUE, 'title' =>'Writings'),
  'scholar_software' => array('weight' => 2, 'primary' => TRUE, 'custom_title' => FALSE, 'title' =>'Software'),
  'data' => array('weight' => 3, 'primary' => TRUE, 'custom_title' => FALSE, 'title' =>'Dataverse'),
  'people' => array('weight' => 4, 'primary' => TRUE, 'custom_title' => TRUE, 'title' =>'Research Group'),
  'classes' => array('weight' => 5, 'primary' => TRUE, 'custom_title' => TRUE, 'title' =>'Class Materials'),
  'links' => array('weight' => 6, 'primary' => TRUE, 'custom_title' => FALSE, 'title' =>'Links'),
  'calendar' => array('weight' => 7, 'primary' => FALSE, 'custom_title' => FALSE, 'title' =>'Calendar'),
  'blog' => array('weight' => 8, 'primary' => FALSE, 'custom_title' => FALSE, 'title' =>'Blog'),
  'announcements' => array('weight' => 9, 'primary' => FALSE, 'custom_title' => FALSE, 'title' =>'Announcements'),
  'documents' => array('weight' => 10, 'primary' => FALSE, 'custom_title' => FALSE, 'title' =>'Documents'),
  'images' => array('weight' => 11, 'primary' => FALSE, 'custom_title' => FALSE, 'title' =>'Images'),
  'reader' => array('weight' => 12, 'primary' => FALSE,  'custom_title' => FALSE, 'title' =>'Feeds'),
  ); 

  $a_menu_items = array();
 //set custom weight for menu items
    install_include(array('menu'));
    foreach ($item_settings as $item => $setting){
      //get the mlid
      $a_mlid = install_menu_get_items($item);
      $mlid = $a_mlid[0]['mlid'];
      if(!$mlid) continue;
      
      //set custom title
      if ($setting['custom_title']) $vsite -> customizer['menu'][$item] = $setting['title'];
      
      $a_menu_items[$mlid] = array('menu' => (($setting['primary'])?'primary':'secondary'), 'weight' => $setting['weight']);
    }
    
  require_once(drupal_get_path('module', 'vsite_menus') .'/includes/vsite_menus.menus.inc');
  $vsite -> settings['menus'] = vsite_menus_menus::create_menus(array('menu_items' => $a_menu_items));
           
    
    //save settings for Gary's twitter account
   $vsite -> settings['reader']['twitter_username'] = 'kinggary';
       
  spaces_save($vsite);
   
  cache_clear_all();
  gkimport_print("Customized primary menu names and weights");
}

/**
 * Looks for files and calls approproiate handler functions
 * to import data
 */
function gkimport_parse_files(){
  //NOTE: Please do not change the order of these files as it can cause problems
  $files =array('pubs_taxonomy.csv', 'gkpubs.bib', 'talks.csv');  //files to parse
  $path = dirname(__FILE__) . '/files/';

  foreach($files as $file){
    $filepath = $path . $file;

    switch($file){

      case 'pubs_taxonomy.csv':
        gkimport_pubs_taxonomy($filepath);
        break;

      case 'gkpubs.bib':
        gkimport_import_pubs($file);
        break;
        
      case 'talks.csv':
        gkimport_import_talks($filepath);
        break;
        
    }
  }
}

/**
 * Parse abstract URL
 * 
 * @return 
 *  an array per the regex matches
 */
function gkimport_parse_abstract_url($node){
  //make curly brackets uniform around urls
     $url = substr($node -> biblio_url,  0, 1) !== '{' ? '{' . $node -> biblio_url : $node -> biblio_url;
     $url  .= substr($url, -1,1 ) !== '}' ? $url  . '}' : $url;
      
     //check to see if http url exists in biblio notes field
     preg_match('/({)(http:\/\/.*?)(})/', $url, $matches);
     return $matches;
 }

/**
 * Import taxonomy terms and save csv information to a system variable
 */
function gkimport_pubs_taxonomy($filepath){
  install_include(array('taxonomy'));
  if (( $handle = fopen($path . $filepath, "r")) !== FALSE) {
    $all_terms = array();
    $account = user_load(array('name' => 'gking'));
    $space = vsite_get_vsite_by_owner($account -> uid);

    //create vocabulary(s)
    $vocab_name =  'Research Interests';
    $properties = array(
    'multiple' => 1,
    'description' => 'Gary King Research Interests',
    'help' => 'Gary King Research Interests',
    );
    $content_types = array(
    'biblio' => 'biblio',
    );

    $vid = install_taxonomy_add_vocabulary($vocab_name, $content_types, $properties);
    if ($vid){
      og_vocab_write_record($space[0] -> group -> nid, $vid);
      variable_set('gkimport_ri_vocab_id', $vid); //keep track of vid because other vocabs may have same name
      $message =  (GKIMPORT_DRUSH_RUN  === 1) ?
      drush_print(t("Created vocabulary: !vocab_name", array('!vocab_name' => $vocab_name))) : '';
    }
    $term_match_data = array();
    $sub_term_match_data = array();

    //parse csv data
    while (($data = fgetcsv($handle, 1024, ",")) !== FALSE) {
      if(strlen($data[1])) $sub_term_match_data[] = array(
      'title' => trim($data[3]),
      'primary' => $data[0],
      'secondary' => $data[1],
      );

      //if title exists already in the array, and another term is to be added
      if (key_exists($data[3], $term_match_data)){
        $val = $term_match_data[$data[3]];
        $term_match_data[$data[3]] = $val . ', ' . trim($data[0]);
        continue;
      }
      else{
        $term_match_data[$data[3]] = $data[0];  //set title to term mapping data in an array
      }
      $all_data[] = $data;
      $all_terms[] = trim($data[0]);
    }

    //refine list of terms - remove duplicates
    $terms = array_unique($all_terms);
    //set title to term mapping data in system variable to be used later
    variable_set('gkimport_taxonomy_data', $term_match_data);
    variable_set('gkimport_taxonomy_subterm_data', $sub_term_match_data);

    //save all publication data from the csv to a system variable to be used later
    variable_set('gkimport_all_pub_data', $all_data);

    //now add terms
    $ri_vid = variable_get('gkimport_ri_vocab_id', '');

    //add top level terms
    $top_level_terms = array(
    1 => array('term' => 'Methods', 'description' => ''),
    2 => array('term' => 'Applications', 'description' => ''),
    );
    foreach($top_level_terms as $top){
      $tid = install_taxonomy_add_term($ri_vid, $top['term'], $top['description']);
      gkimport_update_alias_term($tid);
      gkimport_print("Added top level term: {$top['term']}");
    }

    //add second level terms

    $function_name = array('_gkimport_applications_pub_terms', '_gkimport_methods_pub_terms');
    foreach($function_name as $fn){

      $terms = call_user_func($fn);
      foreach($terms as $name => $description){
        $parent_term = ($fn == '_gkimport_methods_pub_terms') ? 'Methods' : 'Applications';
        $parent_tid = install_taxonomy_get_tid(trim($parent_term),  $ri_vid);
        $properties = array('parent' => array($parent_tid));
        //adding the subterm here with description
        $tid = install_taxonomy_add_term($ri_vid, $name, $description, $properties);
        gkimport_update_alias_term($tid);
        gkimport_print("Added level 2 term: " . $name);
      }
    }
  }
  //add sub level terms
  foreach(array(3, 4) as $level){
    gkimport_add_sub_terms($level);
  }
}


/**
 * add terms to vocab
 */
function gkimport_add_sub_terms($level = 3){
  install_include(array('taxonomy'));
  switch($level){
    case 3:
    $sub_term_desc = _gkimport_pub_third_term_descriptions();
    break;
 
    case 4:
      $sub_term_desc =  _gkimport_pub_fourth_term_descriptions();
      break;
  }   
 
  //get Research Interests vocab ID
  $ri_vid = variable_get('gkimport_ri_vocab_id', '');
  foreach( $sub_term_desc as $parent => $values){
    $parent_tid = install_taxonomy_get_tid(trim($parent),  $ri_vid);
    if(!$parent_tid) {
      gkimport_print("No tid found for: $parent"); 
      continue;
    }
    foreach($values as $term => $description){
      //define and pass the parent term id
      $properties = array('parent' => array($parent_tid));
      //adding the subterm here with description
      $tid = install_taxonomy_add_term($ri_vid, $term, $description, $properties);
      gkimport_update_alias_term($tid);
      gkimport_print("Added level $level term: $term");
    }
  }
}

/**
 * Updates aliases for default terms (tags)
 */
function gkimport_update_alias_default_terms(){
  $sid = gkimport_get_sid();
  $vocabs = og_vocab_get_vocabularies($sid);
  foreach ($vocabs as $obj){
    if ($obj -> name == 'tags'){
      $tree = taxonomy_get_tree($obj -> vid);
      break;
    }
  }
  foreach($tree as $term_obj){
    $tid = $term_obj -> tid;
    $current_dst = db_result(db_query("SELECT dst FROM {url_alias} WHERE src = '%s' ", "taxonomy/term/$tid" ));
    $path =  (preg_match('/^gking\//s', $current_dst, $matches)) ? $current_dst : "gking/$current_dst";
    //remove the "-7" or other number from end of the path
    $exp_path = explode('-', $path);
    db_query("DELETE FROM {url_alias} WHERE src = '%s' ", "taxonomy/term/$tid");
    db_query("INSERT INTO {url_alias} (src, dst) VALUES ('%s', '%s')", "taxonomy/term/$tid",  $exp_path[0]);
    //drush_print("Updated url_alias for default tags term: $tid");
  }
}

function gkimport_update_alias_term($tid = NULL){
  if ($tid){
    $current_dst = db_result(db_query("SELECT dst FROM {url_alias} WHERE src = '%s' ", "taxonomy/term/$tid" ));
    $path =  (preg_match('/^gking\//s', $current_dst, $matches)) ? $current_dst : "gking/$current_dst";   
    db_query("DELETE FROM {url_alias} WHERE src = '%s' ", "taxonomy/term/$tid");
    db_query("INSERT INTO {url_alias} (src, dst) VALUES ('%s', '%s')", "taxonomy/term/$tid",  $path); 
    drush_print("Updated url_alias for term: $tid");   
  }
}

function gkimport_add_third_terms(){
  install_include(array('taxonomy'));
}

/**
 * assign terms to publication nodes
 */
function gkimport_assign_terms(){
  install_include(array('taxonomy'));
  $ri_vid = variable_get('gkimport_ri_vocab_id', '');
  $sid = gkimport_get_sid();
  $subterm_data = variable_get('gkimport_taxonomy_subterm_data', array());
  foreach($subterm_data  as $values){
    if (strlen($values['primary']) && strlen($values['secondary'])){
      $parent_tid = install_taxonomy_get_tid(trim($values['primary']), $ri_vid);      
      $tid = gkimport_taxonomy_get_tid($values['secondary'], $ri_vid, $parent_tid);      
    //  $nid = db_result(db_query("SELECT nid FROM {node} WHERE title = '%s' ", trim($values['title'])));
      $node_arr = db_fetch_array(db_query("SELECT n.nid, n.title, oga.group_nid FROM {node} n INNER JOIN {og_ancestry} oga USING(nid) HAVING n.title = '%s' 
      AND oga.group_nid = %d", trim($values['title']), $sid)); 
         
      if($node_arr['nid'] && $tid){
      $node = node_load($node_arr['nid']);
        db_query("DELETE FROM {term_node} WHERE nid = %d AND tid = %d", $node -> nid, $tid);
        db_query("INSERT INTO {term_node} (nid, vid, tid) VALUES (%d, %d, %d)", $node -> nid, $node->vid, $tid);
        $term_arr[] = array($node -> nid => $tid);
        drush_print("Added term to node: {$values['secondary']} to node {$node -> nid}");

      }
      else{
        drush_print("Could not add term {$values['secondary']} to node {$values['title']} - {$node -> nid}");
      }
    }
  }
  //dpm($term_arr);
  drush_print("Matched on " . count($term_arr) . " terms");
}

/**
 * Matches title and returns the corresponding term(s)
 * @param  
 *  Title of node
 * @return 
 *  Return the term for matching title otherwise return NULL
 */
function gkimport_match_terms($title){
  //term match data
  $tmd = variable_get('gkimport_taxonomy_data', array());
   return isset($tmd[$title]) ? $tmd[$title] : NULL;
}

/**
 * Imports publication nodes from a Bibtex file
 */
function gkimport_import_pubs($filename, $owner = 'gking' ){
  module_load_include('inc', 'biblio', 'biblio.import.export');
  $account = user_load(array('name' => $owner));
  
  $file =new stdClass();
  $file -> filepath = dirname(__FILE__) . '/files/' . $filename;
  $file->filename = $filename;

  //settings params for biblio import
  $p = array(
  'import_file' => $file,
  'filetype' => 'bib',
  'userid' => $account -> uid,
  'terms' => NULL,
  'batch_proc' => (GKIMPORT_DRUSH_RUN === 1)  ? FALSE : TRUE, //set to TRUE to batch process import, otherwise set to false
  'session_id' => microtime(),
  'dummy' => array(),
  'context' => array(
  'message' => t('Parsing file')
    ),
  );
  //batch process the bibtex import
  if ( $p['batch_proc'] === TRUE){
    $session_id = microtime();
    $batch_op = array(
    'title' => t('Importing '. $p['import_file'] ->filename),
    'operations' => array(
    array('biblio_import', array($p['import_file'], $p['filetype'], $p['userid'], $p['terms'], $p['batch_proc'], $p['session_id'])),
    array('biblio_import_batch_operations', array($p['session_id'], $p['userid'], $p['terms'])),
    ),
    'progressive' => TRUE,
    'finished' => 'biblio_import_batch_finished',
    'init_message' => t('Parsing file...'),
    'progress_message' => t('Importing Gary\'s Publications...'),
    'file' => './'. drupal_get_path('module', 'biblio') .'/biblio.import.export.inc'
    );
    batch_set($batch_op);
    $base = variable_get('biblio_base', 'biblio');
    batch_process("$base/import");    
  }
  //non-batch process the bibtex import
  else{ 
    //parse bibtex file and create publication nodes
    $content = biblio_import($p['import_file'], $p['filetype'], $p['userid'], $p['terms'], $p['batch_proc'], $p['session_id'], $p['context']);
    if ($content){
     variable_set('gkimport_pub_nodes', $content);   //an enumerative array of node id's of publications created during the import 
    $message = GKIMPORT_DRUSH_RUN === 1 ?  drush_print(t('Created !num publications total', array('!num' => count($content)))) : '';
    }  
  }
}

function gkimport_update_notes(){
  //$file = GKIMPORT_FS_PATH . '/' . drupal_get_path('module', 'gkimport') . '/files/generate_pubnotes.txt';
  $file = dirname(__FILE__)  . '/files/generate_pubnotes.txt';
  
  $data = unserialize(file_get_contents($file));
 //return dpm($data);

 $match_results = array();
 
  foreach($data as $pubs){
    $matching_nid = db_result(db_query("SELECT nid FROM {node} WHERE title = '%s' and type = '%s' " , $pubs['title'], 'biblio'));
    if ($matching_nid){
      if(strlen($pubs['notes'])){
       $match_results['matches'][] = array('nid' => $pubs['nid'], 'title' => $pubs['title'], 'notes' => $pubs['notes']);
       db_query("UPDATE {biblio} SET biblio_notes = '%s' WHERE nid = %d", $pubs['notes'], $matching_nid);
      }
    }
    else{
      if(strlen($pubs['notes'])){
        $match_results['non_matches'][] = array('nid' => $pubs['nid'], 'title' => $pubs['title'], 'notes' => $pubs['notes']);
      }
    }
  }
  //dpm($match_results);  
}

function gkimport_upload_pdfs(){
  $nids = variable_get('gkimport_pub_nodes', array()); //array of node id's of publications created from biblio import
  //check to see that variable contains data
  if (!empty($nids)) {
    foreach ($nids as $nid){
      $node = node_load($nid);
      foreach(variable_get('gkimport_all_pub_data', array()) as $data ){ 
        if (trim($node -> title) == trim($data[3])){ //$data[3] is the node title
          $file = gkimport_get_pdf($node, $data[2]); //$data[2] is url to pdf
        }
      }
    }
  }
  //loop through again see if any pdfs did not get saved to the database
    foreach(variable_get('gkimport_all_pub_data', array()) as $data ){ 
      $res = db_result(db_query("SELECT  filename FROM {files} WHERE filename = '%s' " , basename(trim($data[2]))));
      if (!$res && strlen(basename(trim($data[2])))) $mismatch_pdfs[] =  array('title' => $data[3] , 'pdf' =>basename(trim($data[2])));      
    }
  
  gkimport_print("PDF - title mismatches");
  drush_print_r($mismatch_pdfs);
}

function gkimport_get_pdf($node, $url = ''){
  if(!strlen($url)) return gkimport_print("no url for node {$node->nid}");
  $path = drupal_get_path('module', 'gkimport');
  $account = user_load(array('name' => 'gking'));
  $files_dir = GKIMPORT_FS_PATH . '/' . variable_get('file_directory_path', conf_path() .'/files') . '/gking/files';

  //define the source path
  $source = '/nfs/www/edu-harvard-gking/htdocs/files/' . basename($url);

  if (!is_file($source)){
    drush_print("File not found: " .  basename($url));
  }

  // download the file
  if(GKIMPORT_DOWNLOAD){
    $cmd =  "cd  $files_dir && wget -t 2 -nv -nc $url";  //no clobber specified so files with same name overwrite
    shell_exec($cmd);
  }
  else{
    // or copy the file from the file system
  //  $fc = file_copy($source, $files_dir, FILE_EXISTS_REPLACE);
  //  if($fc !== 1) drush_print("File could not be copied: " . basename($url));
  }

  if (is_file($source)){
    $file = new stdClass();
    $file -> uid = $account -> uid;
    $file -> nid = $node -> nid;
    $file -> vid = $node -> vid;
    $file -> description = basename($source);
    $file ->list = 1;
    $file -> weight = 0;
    $file -> filename = basename($source);
    $file -> filepath = variable_get('file_directory_path', conf_path() .'/files') . '/gking/files/' . basename($source);
    $file -> filemime = file_get_mimetype($source);
    $file -> filesize = filesize($source);
    $file -> status =1;
    $file -> timestamp = filemtime($source);

    //write data to files table
    drupal_write_record('files', $file);
    $fid = db_last_insert_id('files', 'fid');
    //write data to upload table
    drupal_write_record('upload', $file);    
    db_query("DELETE FROM  {url_alias} WHERE dst = '%s' ", 'files/' . basename($source));
    db_query("INSERT INTO {url_alias} (src, dst) VALUES ('%s', '%s')", "filefield_paths/alias/$fid", 'gking/files/' . basename($source));

    drush_print("Added custom path for file: " . basename($source));

    //return file object
    return $file;
  }
}

function gkimport_update_alias_node($nid){
  $node = node_load($nid); 
  if ($node){
   $path =  (preg_match('/^gking\//s',$node->path, $matches)) ? $node -> path : "gking/{$node -> path}";   
    db_query("DELETE FROM {url_alias} WHERE src = '%s' ", "node/{$node -> nid}");
    db_query("INSERT INTO {url_alias} (src, dst) VALUES ('%s', '%s')", "node/{$node -> nid}",  $path);
  }
}

/**
 * Update aliases for publications
 */
function gkimport_update_aliases(){
  $nids = variable_get('gkimport_pub_nodes', array()); //array of node id's of publications created from biblio import
  //check to see that variable contains data
  if (!empty($nids)) {
    foreach ($nids as $nid){
      $node = node_load($nid);
      $src = "node/{$node -> nid}";
      if (strlen($node -> biblio_url)){
        $path =  explode('http://gking.harvard.edu/', $node -> biblio_url);
        if (strlen($path[1])){
            // publication with an custom link to abstract
          db_query("DELETE FROM {url_alias} WHERE dst = '%s' ", 'gking/' . $path[1]);
          db_query("DELETE FROM {url_alias} WHERE src = '%s' ", $src);
          $fix_path = (preg_match('/^gking\//s', $path[1], $matches)) ? $path[1] : "gking/$path[1]";   
          db_query("INSERT INTO {url_alias} (src, dst) VALUES ('%s', '%s')", $src, $fix_path);
          drush_print("Added custom path $fix_path  for source $src");
        }
      }
      else{        
        // publication without an custom link to abstract
        $current_dst = db_result(db_query("SELECT dst FROM {url_alias} WHERE src = '%s' ", $src));
        $fix_path =  (preg_match('/^gking\//s', $current_dst, $matches)) ? $current_dst : "gking/$current_dst";
        db_query("DELETE FROM {url_alias} WHERE src = '%s' ", $src);
        db_query("INSERT INTO {url_alias} (src, dst) VALUES ('%s', '%s')", $src, $fix_path);
      }
    }
  }
}

function gkimport_parse_profiles(){
  $file = dirname(__FILE__) . '/files/group.html';
  $profile = file_get_contents($file);

  $group = 'Current Research Associates'; //intialize group as this string for first set of profiles

  //check to see if http url exists in biblio notes field
  preg_match_all('/<li>(.*?)<\/li>/s',$profile, $matches); 

  foreach($matches[1] as $info){
    preg_match('/href=\"(.*?)"(.*?)>(.*?)<\/a>(.*)/s',$info, $data); //$data[1]  = website  //$data[3]  = name   //$data[4]  = description
    $website = valid_url(trim($data[1]), TRUE) ? trim($data[1]) : '';
        
    $name = strip_tags(trim($data[3]));
    if (!strlen($name)) continue;  //if no name then continue to next loop

    //take the first occurrance of name in group to mark group sections
    switch($name){
      case 'Christopher Adolph':
        $group = 'Alumni: Students';
        break;

      case 'Greg Adams':
        $group = 'Alumni: Post-Docs';
        break;

      case 'Lada Adamic':
        $group = 'Collaborators';

      default:
        break; // do nothing
    }

    //clean up description text and remove comma if at beginning
    $description =  strip_tags(trim($data[4]));
    $profiles[] = array(
    'name' => $name,
    'description' => ($description[0] == ',') ? substr($description, 1): $description,
    'group' => $group,
    'website' => $website,
    );
  }
  return $profiles;
}

/**
 * Get profile data and save as profile nodes
 */
function gkimport_create_profiles(){
  module_load_include('inc', 'node', 'node.pages');
  install_include(array('taxonomy'));
  $account = user_load(array('name' => 'gking'));
  $vsites = vsite_get_vsite_by_owner($account -> uid);
  $sid = gkimport_get_sid();

  //create new vocab for Research Group
  $vid =  _gkimport_create_rg_vocab($vsites[0]);
  
  //create terms
  _gkimport_create_rg_terms($vid);
  
  $profiles = array_reverse(gkimport_parse_profiles());

  foreach($profiles as $profile){
  //get term id for profile
  $tid = install_taxonomy_get_tid(trim($profile['group']), $vid);
  
    //split firstname and lastname
    $name = _gkimport_split_name($profile['name']);
    $check = db_result(db_query("SELECT CONCAT_WS(' ' , nid, field_person_firstname_value, field_person_lastname_value) as 
   check_name FROM {content_type_person} WHERE field_person_firstname_value = '%s' AND field_person_lastname_value = '%s'",
   $name['firstname'] , $name['lastname']));
    
   //THIS SECTION RUNS WHEN DUPLICATE NAME IS FOUND
   if(strlen( $check )) {    
   $check_name = explode(' ', $check);
   drush_print("Duplicate name encountered:  " . trim($check_name[1]) . ' '  . trim($check_name[2] . ' ' . $profile['group']));   

   //add taxonomy term only
   $nid = trim($check_name[0]);  
   $check_node = node_load($nid);
   db_query('DELETE FROM {term_node} WHERE nid = %d AND tid = %d', $nid, $tid);
   db_query("INSERT INTO {term_node} (nid, vid, tid) VALUES (%d, %d, %d)", $nid, $check_node -> vid, $tid); 
   
   //TODO: need transfer body text to field_person_institution if $profile['group'] == 'Current Research Associates'
  /*if($profile['group'] == 'Current Research Associates'){
     $inst = db_result(db_query("SELECT body from {node_revisions} WHERE nid = %d", $nid));
     if(strlen($inst)){       
       db_query("UPDATE {content_type_person} SET field_person_institution_value = '%s' WHERE nid = %d ", $inst, $nid);
       }
       $description = _gkimport_remove_line_breaks($profile['description']);  
       db_query("UPDATE {node_revisions} SET body = '%s',  teaser = '%s',  uid = %d WHERE nid = %d", $description, $description, (int)$account -> uid, (int)$nid);
       //drush_print("Updating description: for $nid - $description");
    }*/
   continue;
   }
   
    drush_print("Adding Person: " .  $name['firstname'] . ' ' .  $name['lastname'] . ' - ' .  $profile['group']);
    $description = _gkimport_remove_line_breaks($profile['description']);    
    
    $node = new stdClass();
    $node -> type = 'person';
    $node -> status = 1;
    $node -> teaser_include = 1;
    $node -> name = $account -> name;
    $node -> uid = $account -> uid;
    $node-> og_groups = array($sid => $sid);
    // $node-> og_groups_both  = array($sid => $account -> name); // is this the right value??
    $node -> field_person_firstname[0] = array('value' => trim(html_entity_decode($name['firstname'], ENT_COMPAT, 'UTF-8')));
    $node -> field_person_lastname[0] = array('value' => trim(html_entity_decode($name['lastname'], ENT_COMPAT, 'UTF-8')));
    if(strlen($profile['website'])){
    $node -> field_person_website[0] = array('url' => $profile['website']);
    }
    
    //get institution
//  if($profile['group'] == 'Current Research Associates'){
    $node -> body = html_entity_decode($description, ENT_COMPAT, 'UTF-8');
    $node -> teaser = node_teaser(html_entity_decode($description, ENT_COMPAT, 'UTF-8'));    
 //}
 // else{
  //  $node -> field_person_institution[0] = array('value' => html_entity_decode($description, ENT_COMPAT, 'UTF-8'));
  //}
    node_save($node);
    gkimport_update_alias_node($node -> nid);
    db_query("INSERT INTO {term_node} (nid, vid, tid) VALUES (%d, %d, %d)", $node -> nid, $node -> vid, $tid);  
  }
  //special exception
  drush_print("Adding person: Christopher Adolph to Collaborators");  
  /*$special_nid = db_result(db_query("SELECT nid FROM {content_type_person} WHERE field_person_firstname_value = '%s' 
  AND field_person_lastname_value = '%s'", 'Christopher' , 'Adolph'));
  $special_tid =  install_taxonomy_get_tid( 'Collaborators', $vid);
   db_query('DELETE FROM {term_node} WHERE nid = %d AND tid = %d', $special_nid, $special_tid);
   db_query("INSERT INTO {term_node} (nid, vid, tid) VALUES (%d, %d, %d)", $special_nid, $special_nid, $special_tid);    */
}

function _gkimport_remove_line_breaks($text){
  $clean_text = '';

  $arr = explode( "\n", $text );
  if (count($arr)){
    foreach ($arr as $t){
      $clean_text .= trim($t) . ' ';
    }
  }
  return trim($clean_text);
}

/**
 * Helper function to split name into firstname/ lastname
 */
function _gkimport_split_name($name){
  $fullname = explode(' ', $name);
  $firstname = $fullname[0];
  array_shift($fullname); //remove the first name from this array (assumes there is not multiple first names)
  $lastname = implode(' ', $fullname);

  return array('firstname' => $firstname, 'lastname' => implode(' ', $fullname));
}
	
/**
 * Helper function to create Research Group vocabulary
 * @param  object $vsite
 * @return 
 *  integer -vocabulary id
 */
function _gkimport_create_rg_vocab($vsite){
    install_include(array('taxonomy'));

    //create vocabulary(s)
  $vocab_name =  'Research Group';
  $properties = array(
  'multiple' => 1,
  'description' => 'Gary King Research Group',
  'help' => 'Gary King Research Group',
  );
  $content_types = array(
  'person' => 'person',
  );

  $vid = install_taxonomy_add_vocabulary($vocab_name, $content_types, $properties);
  if ($vid){
    og_vocab_write_record($vsite -> group -> nid, $vid);
    variable_set('gkimport_rg_vocab_id', $vid); //keep track of vid because other vocabs may have same name
    return $vid;
  }
}

function _gkimport_create_rg_terms($vid){
  install_include(array('taxonomy'));
  $terms = array('Current Research Associates', 'Alumni: Students', 'Alumni: Post-Docs', 'Collaborators');
  foreach($terms as $term){
  $tid = install_taxonomy_add_term($vid, $term);
  gkimport_update_alias_term($tid);
  }
}

/**
 * Implementation of hook_nodeapi()
 */
function gkimport_nodeapi(&$node, $op){
  if ($node -> type != 'biblio') return;
  $name = 'gking';
  $account = user_load(array('name' => $name));
  switch ($op) { 
    case 'presave':
      //manually set auto title url alias
      $node -> pathauto_perform_alias = 1;   
      break;
    case 'insert':
      if (!vsite_get_vsite()){
        $spaces = vsite_get_vsite_by_owner($account -> uid);
        if (count($spaces) == 1){          
        $check = db_result(db_query("SELECT nid FROM {og_ancestry} WHERE nid = %d", $node -> nid));         
          //added publication to the og
          if($check){
              db_query("UPDATE {og_ancestry} SET group_nid = %d WHERE nid = %d", $spaces[0] -> group -> nid, $node ->nid);                     
          }
          else{
          db_query("INSERT INTO {og_ancestry} (nid, group_nid) VALUES (%d, %d)", $node ->nid, $spaces[0] -> group -> nid);
          }
         drush_print(t("Imported publication: !title", array('!title'=> $node->title)));
          //save custom path
          $matches = gkimport_parse_abstract_url($node);
          if (count($matches) && strlen($matches[2])){
            //$node -> path = strstr($matches[2], 'files');
            $src = db_result(db_query("SELECT src FROM {url_alias} WHERE src = '%s'", "node/{$node -> nid}"));
            $sql = ($src) ? db_query("UPDATE {url_alias} SET dst = '%s' WHERE src = '%s'", strstr($matches[2], 'files'), $src) :
            db_query("INSERT INTO {url_alias} (src, dst) VALUES ('%s', '%s')", "node/{$node -> nid}", strstr($matches[2], 'files'));
          }
        }
        else{
          return drush_print("Error occured: user has more than 1 web site"); // this is very unlikely
        }
      }
      break;
  }
}

function gkimport_import_bio(){
  //$path = GKIMPORT_FS_PATH . '/'.  drupal_get_path('module', gkimport) . '/files/bio.txt';  
  $path = dirname(__FILE__)  . '/files/bio.txt';
   
  if(!is_file($path)){
    return drush_print("No file found for bio text");
  }
  $text = file_get_contents($path);  
  $account = user_load(array('name' => 'gking'));  
  $node = new stdClass();
  $node -> type = 'bio';
  $node -> title = 'Gary King Bio';
  $node -> body = _gkimport_remove_line_breaks($text);
  $node -> name = $account -> name;
  $node -> uid = $account -> uid;
  node_save($node);
  gkimport_node_to_og($node -> nid, $account);
  gkimport_update_alias_node($node -> nid);
  if ($node -> nid) drush_print("Added Bio: {$node -> title}");
}

function gkimport_import_links(){
  //$path = GKIMPORT_FS_PATH . '/'.  drupal_get_path('module', gkimport) . '/files/links.csv';
  $path = dirname(__FILE__)  . '/files/links.csv';
  
  if(!is_file($path)){
    return drush_print("No file found for links");
  }

  $account = user_load(array('name' => 'gking'));
  if($spaces = vsite_get_vsite_by_owner($account -> uid)){
    $sid = $spaces[0] -> group -> nid;
  }

  if (( $handle = fopen($path, "r")) !== FALSE) {
    while (($data = fgetcsv($handle, 1024, ",")) !== FALSE) {
      //if title exists already in the array, and another term is to be added

      $node = new stdClass();
      $node -> type = 'link';
      $node -> title = $data[0];
      $node -> field_link_href[0] = array('url' => $data[1]);
      $node -> name = $account -> name;
      $node -> uid = $account -> uid;
      node_save($node);
      gkimport_node_to_og($node -> nid, $account, $sid);
      gkimport_update_alias_node($node -> nid);
      drush_print("Added link: {$node -> title}");
    }
  }
}

/**
 * Add a node to an OG
 */
function gkimport_node_to_og($nid, $account, $sid = NULL){
if(!$sid){  
  if($spaces = vsite_get_vsite_by_owner($account -> uid)){
  $sid = $spaces[0] -> group -> nid;  
  }
}
if($sid){  
    db_query("DELETE FROM {og_ancestry} WHERE nid = %d AND group_nid = %d", $nid, $sid);
    db_query("INSERT INTO {og_ancestry} (nid, group_nid) VALUES (%d, %d)", $nid, $sid);
  }
}

function gkimport_import_classes(){  
  //$path = GKIMPORT_FS_PATH . '/'.  drupal_get_path('module', gkimport) . '/files/classes.csv';    
  $path = dirname(__FILE__)  . '/files/classes.csv';    
    
  if(!is_file($path)){
    return drush_print("No file found for classes");
  }
   $account = user_load(array('name' => 'gking'));
  if($spaces = vsite_get_vsite_by_owner($account -> uid)){
    $sid = $spaces[0] -> group -> nid;
  }

  if (( $handle = fopen($path, "r")) !== FALSE) {
    while (($data = fgetcsv($handle, 1024, ",")) !== FALSE) {
      //if title exists already in the array, and another term is to be added

      $node = new stdClass();
      $node -> type = 'class';
      $node -> title = $data[0];
      $node -> body = $data[1];
      $node -> teaser = node_teaser($data[1]);
      $node -> field_class_link[0] = array(
      'url' => $data[2],
      'title' => strlen($data[2]) ? 'Syllibus' : '',
      );
      $node -> name = $account -> name;
      $node -> uid = $account -> uid;
      //$node -> path = "test/$nid";
      node_save($node);
      gkimport_node_to_og($node -> nid, $account, $sid);
      gkimport_update_alias_node($node ->nid);
      drush_print("Added class: {$node -> title}");
    }
  }	
}
/**
 * Enter description here...
 * 
 * @param $source  the path to the source image
 * @param $field_name the name of the cck field 
 * @param $node the node object to upload the image to (passed by reference)
 * @param  $save TRUE to save the node, FALSE to just return the node object
 */
function gkimport_import_presentations(){
  $sid = gkimport_get_sid();
  $path = dirname(__FILE__)  . '/files/talks.csv';

  if(!is_file($path)){
    return drush_print("No file found for presentations");
  }
   //absolute path to files directory
  $files_dir = GKIMPORT_FS_PATH . '/' . variable_get('file_directory_path', conf_path() .'/files') . '/gking/files';
  $gking_files_dir = '/nfs/www/edu-harvard-gking/htdocs/talks';
  $field_name = 'field_presentation_file';
  $account = user_load(array('name' => 'gking'));

  if (( $handle = fopen($path, "r")) !== FALSE) {
    while (($data = fgetcsv($handle, 1024, ",")) !== FALSE) {
      //if title exists already in the array, and another term is to be added
     
      if($data[0] == 'title') continue;
      
      $node = new stdClass();
      $node -> type = 'presentation';
      $node -> title = $data[0];
      $node -> field_presentation_location[0]['value'] = $data[1];
      $node -> field_presentation_location[0]['_error_element'] = 'field_presentation_location';
      
      if (strlen($data[2])){
        $start = explode('/' , $data[2]);
        $end = strlen($data[3]) ? explode('/' , $data[3]) : array();
        $date = gkimport_convert_date_times($start, $end);
        $node -> field_presentation_date[0]['value'] = $date['value'];
        $node -> field_presentation_date[0]['value2'] = $date['value'];
      }
      
      // import files and add to $node object
      // slides
      if (strlen($data[4])){
        $source = $gking_files_dir   . '/' . basename($data[4]);
        if(!is_file($source)){
          drush_print("Presentation file not found: "  . basename($data[4]));
        }
        gkimport_add_filefield_file($source, $field_name, $node, FALSE, gkimport_get_sid(), 0, $account);
        $node -> field_presentation_file[0]['data']['description'] = 'Slides';
      }
      // printable slides
      if (strlen($data[5])){
        $source = $gking_files_dir  . '/' . basename($data[5]);
        if(!is_file($source)) {
          drush_print("Presentation file not found: "  . basename($data[4]));
        }
        gkimport_add_filefield_file($source, $field_name, $node, FALSE, gkimport_get_sid(), 1, $account);
        $node -> field_presentation_file[1]['data']['description'] = 'Printable slides';
      }
      $node -> name = $account -> name;
      $node -> uid = $account -> uid;    
      
      node_save($node);     
      
      gkimport_node_to_og($node -> nid, $account, $sid);
      drush_print("Added presentation: {$node -> title}");
    }
    gkimport_presentations_update_alias();
    gkimport_presentations_node_access_fix();
  }
}
/**
 * Update url aliases for presentations
 */
function gkimport_presentations_update_alias(){
  drush_print("Updating url aliases for presentations");
  $sid = gkimport_get_sid();
  $sql = db_query("SELECT n.nid, n.type, oga.group_nid FROM {node} n INNER JOIN {og_ancestry} oga USING(nid)
  HAVING n.type = '%s' AND  oga.group_nid = %d", 'presentation' , $sid );
  while($data = db_fetch_object($sql)){
    $src = "node/{$data ->nid}";
    $current_dst = db_result(db_query("SELECT dst FROM {url_alias} WHERE src = '%s' ", $src));
    $fix_path =  (preg_match('/^gking\//s', $current_dst, $matches)) ? $current_dst : "gking/$current_dst";
    drush_print("Path: $fix_path");
    db_query("DELETE FROM {url_alias} WHERE src = '%s' ", $src);
    db_query("INSERT INTO {url_alias} (src, dst) VALUES ('%s', '%s')", $src, $fix_path);
  }
}

/**
 * Fix node access for presentations
 */
function gkimport_presentations_node_access_fix(){
  drush_print("Updating node_access for presentations");

  $sid = gkimport_get_sid();
  $arr = array();
  $sql = db_query("SELECT oga.nid, oga.group_nid, na.gid, na.realm, na.grant_view, na.grant_update, na.grant_delete
FROM {og_ancestry} oga INNER JOIN {node_access} na USING ( nid ) HAVING na.realm = '%s' AND oga.group_nid = %d", 'all', $sid);
  while($data = db_fetch_object($sql)){
    $arr[] = $data-> nid;
  }

  foreach($arr as $nid){
    $type = db_result(db_query("SELECT type FROM {node} where nid = %d" , $nid));
    if ($type == 'presentation'){
      db_query("DELETE FROM {node_access} WHERE nid = %d", $nid);
      db_query("INSERT INTO {node_access} (nid, gid, realm, grant_view, grant_update, grant_delete) VALUES (%d, %d, '%s', %d, %d, %d)",  $nid, 0, 'og_public', 1, 0, 0);
      db_query("INSERT INTO {node_access} (nid, gid, realm, grant_view, grant_update, grant_delete) VALUES (%d, %d, '%s', %d, %d, %d)",
      $nid, $sid, 'og_admin', 1, 1, 1);
      db_query("INSERT INTO {node_access} (nid, gid, realm, grant_view, grant_update, grant_delete) VALUES (%d, %d, '%s', %d, %d, %d)",
      $nid, $sid, 'og_subscriber', 1, 0, 0);
    }
  }
}
/**
 * Make sure node access is correct
  */
function gkimport_node_access_check(){
  drush_print("Node access check...");
  $sid = gkimport_get_sid();
  $nids = db_query("SELECT nid FROM {node_access} WHERE nid > %d", $sid);
  while ($data = db_fetch_object($nids)){
    $node = node_load( $data -> nid);
    if($node -> og_groups[$sid] == $sid){     
    db_query("DELETE FROM {node_access} WHERE nid = %d", $node -> nid);
    db_query("INSERT INTO {node_access} (nid, gid, realm, grant_view, grant_update, grant_delete) VALUES (%d, %d, '%s', %d, %d, %d)",  $node->nid, 0, 'og_public', 1, 0, 0);
    db_query("INSERT INTO {node_access} (nid, gid, realm, grant_view, grant_update, grant_delete) VALUES (%d, %d, '%s', %d, %d, %d)",
    $node->nid, $sid, 'og_admin', 1, 1, 1);
    db_query("INSERT INTO {node_access} (nid, gid, realm, grant_view, grant_update, grant_delete) VALUES (%d, %d, '%s', %d, %d, %d)",
    $node->nid, $sid, 'og_subscriber', 1, 0, 0);
    }
  }
}

/**
 * Change the biblio type of selected nodes  to 
 * "software" per Gary's bibtex file
 */
function gkimport_software_pubs_set(){
  $biblio_type_id = db_result(db_query("SELECT tid FROM {biblio_types} WHERE name = '%s' " , 'Software')); // should be 113
  foreach(_gkimport_software_pubs() as $title){
    $nid = db_result(db_query("SELECT nid FROM {node} WHERE title = '%s' ",$title));
    if ($nid){
      $node = node_load($nid);
      db_query("UPDATE {biblio} SET biblio_type = %d WHERE nid =  %d" , $biblio_type_id, $nid); 
      drush_print("Updated biblio type to Software for node: $nid {$node -> title}");
    }
  }
}


/**
 * Implementation of hook_form_alter()
 * Remove the redirect from 'biblio_admin_types_add_form' form by changing the submit function
 */
function gkimport_form_alter(&$form, $form_state, $form_id) {
  if ($form_id == 'biblio_admin_types_add_form') {
    if (GKIMPORT_DRUSH_RUN == 1){
      $form['#submit'] = array('gkimport_biblio_admin_types_add_form_submit');
    }
  }
}

/**
 * Change the biblio type of selected nodes to Data
 */
function gkimport_data_pubs_set(){
  $biblio_type_id = db_result(db_query("SELECT tid FROM {biblio_types} WHERE name = '%s' " , 'Data'));
  if(!$biblio_type_id){
    $filepath = drupal_get_path('module', 'biblio') . '/biblio.admin.inc';
    include_once($filepath);
    //create custom biblio type called Data
    $form_state['values']['name'] = 'Data';
    $form_state['values']['description'] = '';
    drupal_execute('biblio_admin_types_add_form', $form_state);
    $biblio_type_id = db_result(db_query("SELECT tid FROM {biblio_types} WHERE name = '%s' " , 'Data'));
    if($biblio_type_id) {
      drush_print("Created biblio type: Data");
    }
  }
  foreach(_gkimport_data_pubs() as $title){
    $nid = db_result(db_query("SELECT nid FROM {node} WHERE title = '%s' ",$title));
    if ($nid){
      $node = node_load($nid);
      db_query("UPDATE {biblio} SET biblio_type = %d WHERE nid =  %d" , $biblio_type_id, $nid);
      drush_print("Updated biblio type to Data for node: $nid {$node -> title}");
    }
  }
}


/**
 * Assign the custom theme
 */
function gkimport_assign_theme(){
  $theme_name = 'gking';
  $vsite = spaces_load("og", gkimport_get_sid(), $is_active = FALSE);
  $vsite -> group -> og_theme = $theme_name;
  spaces_save($vsite);
  drush_print("Assigned custom theme: $theme_name");
}

/**
 * Function to import Gary's contact page
 */
function gkimport_import_contact_page(){
  $account = user_load(array('name' => 'gking'));
  $sid = gkimport_get_sid();
  $node = new stdClass();
  $node -> type = 'page';
  $node -> title = 'Contact';
  $node -> body = _gkimport_get_contact_body();
  $node -> teaser = node_teaser(_gkimport_get_contact_body());
  $node -> name = $account -> name;
  $node -> uid = $account -> uid;
 /* 
 //NOT ADDING MENU LINK
 $node -> menu = array(
    'module' => 'menu',
    'link_title' => 'Contact',
    'parent' =>'features:0',
    'menu_name' => 'features',
    'weight' => 10,
  );
  */
  node_save($node);
  gkimport_node_to_og($node -> nid, $account, $sid);
  gkimport_update_alias_node($node -> nid);
  drush_print("Added Contact Page");
}

/**
 * Returns contact page body
 */
function _gkimport_get_contact_body(){
  $str = <<<CONTENT
<h2>Online, Phone and FAX</h2> <ul> <li>Email: <a href="../contact_owner">Contact Gary King</a></li> <li>URL: <a href="http://GKing.Harvard.Edu">http://GKing.Harvard.Edu</a></li> <li>Assistant: (617) 495-9271 </li> <li>Direct: (617) 495-2027 </li> <li>eFax: (617) 812-8581 </li> </ul> <h2>Mailing Address</h2> <ul> <li><a href="http://iq.harvard.edu"> Institute for Quantitative Social Science</a><br> 1737 Cambridge Street<br> <a href="http://www.harvard.edu">Harvard University</a><br> <a href="http://www.ci.cambridge.ma.us/">Cambridge</a>, <a href="http://www.mass.gov"> MA</a> <a href="http://maps.google.com/maps?sourceid=mozclient&amp;oe=utf-8&amp;q=02138&amp;um=1&amp;ie=UTF-8&amp;split=0&amp;gl=us&amp;ei=26nsSczkNcrHtgeOm63EBQ&amp;sa=X&amp;oi=geocode_result&amp;ct=title&amp;resnum=1"> 02138</a> </li> </ul> <h2>Maps</h2> <ul> <li><a href="http://map.harvard.edu">Harvard University</a></li> <li><a href="http://www.harvardsquare.com/home/about/Maps.aspx">Harvard Square</a></li> <li><a href="http://www.mbta.com/">The T</a></li> </ul> <h2>Harvard Directory</h2> <ul> <li><a href="https://www.directory.harvard.edu/phonebook/">Search for people at Harvard</a></li> </ul>
CONTENT;
  return $str;
}

/**
 * Returns site id for gary's site
 */
function gkimport_get_sid(){
if (variable_get('gkimport_site_id', 0) > 0) return variable_get('gkimport_site_id', 0);

 if (is_int(GKIMPORT_SID) && GKIMPORT_SID > 0) return GKIMPORT_SID; 
  $account = user_load(array('name' => 'gking'));
  $vsites = vsite_get_vsite_by_owner($account -> uid);
  return $vsites[0] -> group -> nid; 
}

/**
 * Saves layout settings from saved string
 */
function gkimport_save_site_layout($drush_run = 0){
  define(GKIMPORT_DRUSH_RUN, $drush_run);
  $layout_file = dirname (__FILE__) . '/files/layout.txt';
  $s_settings = file_get_contents($layout_file);
  $vsite = spaces_load("og", gkimport_get_sid());  
  if($vsite && strlen($s_settings)){
    $vsite -> settings['layout']['gking'] = unserialize(trim($s_settings));
    spaces_save($vsite);
    gkimport_print("Site layout settings have been imported");
  }
  else{
    gkimport_print("Error: layout settings could not be imported");
  }
}
/**
 * Exports current layout settings to serialized string
 */
function gkimport_export_site_layout($drush_run = 0){
  define(GKIMPORT_DRUSH_RUN, $drush_run);
  $layout_file = dirname (__FILE__) . '/files/layout.txt';
  $vsite = spaces_load("og", gkimport_get_sid());
  if ($vsite){
    if(file_put_contents($layout_file, serialize($vsite -> settings['layout']['gking']))){
      gkimport_print("Site layout settings have been exported");
    }
    else{
      gkimport_print("Error: layout settings could not be exported");
    }
  }
}

function gkimport_save_sample_pages(){
  //save a sample announcement
  $account = user_load(array('name' => 'gking'));
  $sid = gkimport_get_sid();
  $node = new stdClass();
  $node -> type = 'announcement';
  $node -> title = 'Office Hours extended to 3PM on Thursdays through April 4, 2010';
  $node -> body = 'Test announcement';
  $node -> teaser = 'Test announcement';
  $node -> name = $account -> name;
  $node -> uid = $account -> uid;
  node_save($node);
  gkimport_node_to_og($node -> nid, $account, $sid);
  gkimport_update_alias_node($node -> nid);
  drush_print("Added sample announcement");

  //cache_clear_all();
  
  //mark a couple nodes as featured nodes so feature posts appears on front page
  //choose any 3 publications
/*  $flag = flag_get_flag('featuredposts');
  $res = db_query_range("SELECT nid FROM {node} WHERE type = '%s' AND uid = '%s' ", 'biblio', $account -> uid, 0,3);
  while ($data = db_fetch_object($res)){
    // Flag the node
    $flag->flag('flag', $data -> nid, $account);
    drush_print("Flagged node {$data -> nid} as featured post");
  }*/
}

function gkimport_import_talks($file){
  if (!strlen($file)) $file = dirname(__FILE__) . '/files/talks.csv';  //TODO: remove this
  if (( $handle = fopen($file, "r")) !== FALSE) {
    while (($data = fgetcsv($handle, 1024, ",")) !== FALSE) {
      $talks[]= array(
      'Title' => $data[0],
      'Location' => $data[1],
      'Start date' => $data[2],
      'End date' => $data[3],
      'Slides' => $data[4],
      'Printable slides' => $data[5],
      'Related research' => $data[6],
      'Paper1' => $data[7],
      'Paper2' => $data[8],
      'Website' => $data[9],
      'Book' => $data[10],
      'DVN paper' => $data[11],
      'Data Citation paper' => $data[12],
      'Zelig paper' => $data[13],
      'Text Extraction paper' => $data[14],
      'Verbal Autopsy paper' => $data[15],
      'Design paper' => $data[16],
      'Matched Pair Methods paper' => $data[17],
      'Paper abstract' => $data[18],
      );
    }
  }
 
  //loop though the presenetation data
  foreach($talks as $talk){
  //construct and save the node here     
    
  }
 // dpm($talks);
}

function gkimport_cleanup(){
	//clean up any empty url aliases
	$res = db_query("SELECT * FROM {url_alias} WHERE dst = '%s' ", '');
	while($data = db_fetch_object($res)){	
	  drush_print("Cleanup: removing emtpy alias: {$data -> src}");
	  db_query("DELETE FROM {url_alias} WHERE src = '%s' ", $data -> src);
	}
	
	//fix selected publication titles with special punctuation
	gkimport_update_publication_titles();
	
	//Update term names
	gkimport_update_term_names();	
	
	//update url aliases for default terms
      gkimport_update_alias_default_terms();
}

/**
 * API function - will either install or re-enable
 * modules if they exist
 */
function gkimport_enable_modules($module_list = array()){
  if(!is_array($module_list) || !count($module_list)) return false;
  $modules_enabled = array();
  //make sure following modules are enabled for gary's site
  include_once('includes/install.inc');
  module_rebuild_cache();
  foreach ( $module_list as $module){
    if (module_exists($module)) continue;
    //check if module is installed but not enabled
    $installed = db_result(db_query("SELECT name FROM {system} WHERE name = '%s' AND type = '%s' AND status = %d ", $module, 'module', 0));
    $enable = ($installed) ? module_enable(array($module)) : drupal_install_modules(array($module));
    gkimport_print("Enabled module: $module");
    $modules_enabled[] = $module;
  }
  return $modules_enabled;
}

/**
 * Utilty function to fix abstracts spacing
 */
function gkimport_fix_abstacts_spacing(){
  $res = db_query("SELECT nid, biblio_abst_e from {biblio}");
  while($data = db_fetch_object($res)){
    if(!strlen($data ->biblio_abst_e)) continue;
  $abs_formatted = (str_replace('  ', ' ', _gkimport_remove_line_breaks($data ->biblio_abst_e)));
  db_query("UPDATE {biblio} SET biblio_abst_e = '%s' WHERE nid = %d", $abs_formatted, $data -> nid);  
  }
}

/**
 * Abstraction layer function to check if run from drush 
 * command before printing feedback or error text
 */
function gkimport_print($text){
  switch(GKIMPORT_DRUSH_RUN){
    case 0;
    return print (t("$text"));
    break;

    case 1:
      return drush_print (t("$text"));
      break;

    default:
      return print (t("$text"));
      break;
  } 
}
