<?php
// $Id: activity.module,v 1.1.2.2.2.30.2.31.2.49 2009/08/26 00:38:37 sirkitree Exp $
/**
 * @file
 * Primarily Drupal hooks and global API functions to manipulate activity.
 *
 * This is the main module file for Activity.
 */

/**
 * Get a list of modules that support the current activity API.
 */
function activity_get_module_info($module_spec = NULL) {
  static $cache = NULL;
  if (!isset($cache)) {
    $cache = array();
    foreach (module_implements('activity_info') as $module) {
      $function = $module . '_activity_info';
      $info = $function();
      if (isset($info->api) && $info->api == 2.000) {
        // Set the defaults. Not all modules implement the full api
        if (!isset($info->path)) {
          $info->path = drupal_get_path('module', $module);
        }
        elseif (file_exists('./'. $info->path .'/'. $module .'.activity.inc')) {
          require_once './'. $info->path .'/'. $module .'.activity.inc';
        }
        if (!isset($info->hooks)) {
          $info->hooks = array();
        }
        if (!isset($info->objects)) {
          $info->objects = array();
        }
        if (!isset($info->realms)) {
          $info->realms = array();
        }
        if (!isset($info->types)) {
          $info->types = array();
        }
        $cache[$module] = $info;
      }
    }
  }
  if ($module_spec) {
    return $cache[$module_spec];
  }
  return $cache;
}

/**
 * Implementations of hook_activity_info().
 *
 * This one is used as the base to reduce errors when updating.
 */
function _activity_activity_info() {
  $info = new stdClass;
  $info->api = 2;
  $info->path = drupal_get_path('module', 'activity') .'/modules';
  $info->realms = array();
  $info->type_options = array();
  return $info;
}

function comment_activity_info() {
  $info = _activity_activity_info();
  $info->name = 'comment';
  $info->object_type = 'comment';
  $info->objects = array('author' => 'comment'); // array key is the label
  $info->hooks = array('comment' => array('insert', 'update'));
  $info->realms = array('comment' => 'Comment'); // do we need a t()?
  foreach (node_get_types() as $type) {
    $info->type_options[$type->type] = t($type->name);
  }
  return $info;
}

function node_activity_info() {
  $info = _activity_activity_info();
  $info->name = 'node';
  $info->object_type = 'node';
  $info->objects = array('author' => 'node'); // the array key is the label
  $info->hooks = array('nodeapi' => array('delete', 'insert', 'update', 'view'));
  foreach (node_get_types() as $type) {
    $info->type_options[$type->type] = t($type->name);
  }
  return $info;
}

function user_activity_info() {
  $info = _activity_activity_info();
  $info->name = 'user';
  $info->object_type = 'user';
  $info->objects = array('account' => 'account'); // array key is the label
  $info->hooks = array('user' => array('insert', 'update', 'login', 'logout', 'view'));
  $info->type_options = user_roles();
  return $info;
}

/**
 * Implementation of hook_help().
 */
function activity_help($path, $arg) {
  switch ($path) {
    case 'admin/help#activity':
      $output = '<p>'. t('For more information, see the online handbook entry for <a href="@activity">Activity module</a>.', array('@activity' => 'http://drupal.org/handbook/modules/activity/')) .'</p>';
      return $output;
    case 'admin/settings/activity':
      $output = '<p>'. t('Please read the developer documentation in the DEVELOPER.txt or in the <a href="@activity">handbook entry</a>.', array('@activity' => 'http://drupal.org/handbook/activity/developer')) .'</p>';
      return $output;
    case 'admin/settings/actions/configure':
      return '<p>'. t('<strong>Please see <a href="@activity">this thread</a> for more details on how to setup an activity.</strong>', array('@activity' => 'http://groups.drupal.org/node/19249#comment-67046')) .'</p>';
    case 'user/%/activity/settings':
      return '<p>'. t('Activity provides an opt-out system of permission. By default all of your activity on the system which is setup to be recorded by the site administrator is recorded and displayed to everyone. Here you can choose which of these that you would <strong>not</strong> like to be recorded.') .'<p>';
  }
}

/**
 * Implementation of hook_perm().
 */
function activity_perm() {
  return array('manage own activity settings', 'administer activity');
}

/**
 * Implementation of hook_menu().
 */
function activity_menu() {
  $items = array();
  $items['activity/%'] = array(
    'title' => 'View',
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );
  $items['activity/%/delete'] = array(
    'title' => 'Delete',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('activity_delete_confirm', 1),
    'access arguments' => array('administer activity'),
    'file' => 'activity.admin.inc',
    'type' => MENU_CALLBACK,
  );
  $items['user/%user/activity/settings'] = array(
    'title' => 'Activity privacy settings',
    'description' => 'Modify your feed settings',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('activity_user_settings', 1),
    'access arguments' => array('manage own activity settings'),
    'file' => 'activity.admin.inc',
    'type' => MENU_LOCAL_TASK,
  );
  $items['admin/settings/activity'] = array(
    'title' => 'Activity publisher templates',
    'description' => 'Modify how your activity messages will look',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('activity_form'),
    'access arguments' => array('administer activity'),
    'file' => 'activity.admin.inc',
  );
  $items['admin/settings/activity/list'] = array(
    'title' => 'List',
    'type' => MENU_DEFAULT_LOCAL_TASK,
  );
  $items['admin/settings/activity/create'] = array(
    'title' => 'Create',
    'description' => 'Modify how your activity messages will look',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('activity_form', 3),
    'access arguments' => array('administer activity'),
    'file' => 'activity.admin.inc',
    'type' => MENU_LOCAL_TASK,
    'weight' => 2,
  );
  $items['admin/settings/activity/settings'] = array(
    'title' => 'Settings',
    'description' => 'Modify the settings for how activity behaves',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('activity_settings_form'),
    'access arguments' => array('administer activity'),
    'file' => 'activity.admin.inc',
    'type' => MENU_LOCAL_TASK,
    'weight' => 3,
  );
  $items['admin/settings/activity/configure/%actions'] = array(
    'title' => 'Edit',
    'description' => 'Modify how your activity messages will look',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('activity_form', 3, 4),
    'access arguments' => array('administer activity'),
    'file' => 'activity.admin.inc',
    'type' => MENU_CALLBACK,
  );
  $items['admin/settings/activity/delete/%actions'] = array(
    'title' => 'Delete',
    'description' => 'Remove an activity action and associated trigger assignment',
    'page callback' => 'drupal_get_form',
    'page arguments' => array('activity_actions_delete_form', 4),
    'access arguments' => array('administer activity'),
    'file' => 'activity.admin.inc',
    'type' => MENU_CALLBACK,
  );
  return $items;
}

/**
 * Implementation of hook_nodeapi().
 */
function activity_nodeapi(&$node, $op, $a3 = NULL, $a4 = NULL) {
  if ($op == 'delete') {
    // Remove all activity records for this node.
    db_query("DELETE m, at, aa, a FROM {activity} a
              LEFT JOIN {activity_access} aa ON aa.aid = a.aid
              INNER JOIN {activity_targets} at ON at.aid = a.aid
              INNER JOIN {activity_messages} m ON m.amid = at.amid
              WHERE a.nid = %d", $node->nid);
  }
}

/**
 * Implementation of hook_user().
 */
function activity_user($op, &$edit, &$account, $category = NULL) {
  if ($op == 'delete') {
    // Remove all activity records for this user.
    db_query("DELETE m, at, aa, a FROM {activity} a
              LEFT JOIN {activity_access} aa ON aa.aid = a.aid
              INNER JOIN {activity_targets} at ON at.aid = a.aid
              INNER JOIN {activity_messages} m ON m.amid = at.amid
              WHERE a.uid = %d", $account->uid);
  }
}

/**
 * Implementation of hook_action_info().
 *
 * Other modules can provide the necessary hooks that they want to provide to
 * us. For instance, node.activity.inc will return array(
 *   'nodeapi' => array('presave', 'delete', 'insert', 'update', 'view')
 * );
 *
 * @see activity_record_form()
 * @see activity_record_submit()
 * @see activity_record()
 */
function activity_action_info() {
  $hooks = array();
  foreach (activity_get_module_info() as $module => $info) {
    $hooks = array_merge($hooks, $info->hooks);
  }
  return array(
    'activity_record' => array(
      'description' => t('Record an activity'),
      'type' => 'activity',
      'configurable' => TRUE,
      'hooks' => $hooks,
    ),
  );
}

/**
 * Present a configuration form for our action.
 *
 * @param array $context
 *   Passed in from actions.
 * @return array $form
 */
function activity_record_form($context) {
  // @todo: activities are no longer compatible with core action configuration
  //    as they need more parameters than it allows. This should simply display
  //    a notice to anyone who tries to use it that it is incompatible and
  //    direct them to the Activity publisher templates
  // Set default values for form.
  $context['author-pattern'] = (!isset($context['author-pattern'])) ? '' : $context['author-pattern'];
  $context['everyone-pattern'] = (!isset($context['everyone-pattern'])) ? '' : $context['everyone-pattern'];
  $form['author-pattern'] = array(
    '#type' => 'textfield',
    '#title' => t('Author message'),
    '#default_value' => $context['author-pattern'],
    '#maxlength' => '254',
    '#description' => t('Using the available tokens, enter a message as how it should <strong>appear to the Author</strong> of this particular activity.'),
  );
  $form['everyone-pattern'] = array(
    '#type' => 'textfield',
    '#title' => t('Public message'),
    '#default_value' => $context['everyone-pattern'],
    '#maxlength' => '254',
    '#description' => t('Using the available tokens, enter a message as how it should <strong>appear to anyone who is <em>not</em> the author</strong> of this particular activity.'),
  );
  $form['token_help'] = array(
    '#type' => 'fieldset',
    '#title' => t('Available tokens'),
    '#collapsible' => TRUE,
    '#collapsed' => TRUE,
  );
  $form['token_help']['tokens'] = array(
    '#type' => 'markup',
    '#theme' => 'activity_token_help',
  );
  return $form;
}

/**
 * This is a replacement for Token's token_get_list().
 *
 * It is used only by theme_activity_token_help(), above.
 *
 * This is a duplicate of the Token's function, but with a small modification:
 * the $type parameter is now $types, allowing for listing tokens from several
 * categories.
 */
function activity_token_get_list($types = array('all')) {
  token_include();
  $return = array();
  foreach ($types as $type) {
    foreach (module_implements('token_list') as $module) {
      $function = $module .'_token_list';
      $result = $function($type);
      if (is_array($result)) {
        foreach ($result as $category => $tokens) {
          foreach ($tokens as $token => $title) {
            $return[$category][$token] = $title;
          }
        }
      }
    }
  }
  // For aesthetic reasons, we don't want the 'global' section to appear in
  // varying places, so let's move it to the bottom.
  if (isset($return['global'])) {
    $global = $return['global'];
    unset($return['global']);
    $return['global'] = $global;
  }
  return $return;
}

/**
 * This allows other module to extend the current token list of other modules.
 *
 * @see comment_activity_token_list
 * @see activity_token_values
 */
function activity_token_list($type = 'all') {
  if ($type == 'activity' || $type == 'all' || function_exists($type .'_activity_token_list')) {
    $token_list = array();
    foreach (activity_get_module_info() as $module => $info) {
      if (function_exists($module .'_activity_token_list')) {
        $token_list = array_merge($token_list, call_user_func($module .'_activity_token_list', $module));
      }
    }
    return $token_list;
  }
}

function activity_token_values($type, $object = NULL, $options = array()) {
  $token_values = array();
  foreach (activity_get_module_info() as $module => $info) {
    if (function_exists($module .'_activity_token_values')) {
      if ($type == $module) {
        $token_values = array_merge($token_values, call_user_func($module .'_activity_token_values', $module, $object));
      }
    }
  }
  return $token_values;
}

/**
 * Process activity_record form submissions.
 *
 * @param array $form
 * @param array $form_state
 * @return array $params
 */
function activity_record_submit($form, $form_state) {
  $form_values = $form_state['values'];
  // Process the HTML form to store configuration. The keyed array that
  // we return will be serialized to the database.
  $params = array(
    'author-pattern' => $form_values['author-pattern'],
    'everyone-pattern' => $form_values['everyone-pattern'],
  );
  return $params;
}

/**
 * determines if the current trigger should be ignored
 *
 * @param stdClass $object
 * the object passed in by trigger.module
 *
 * @param array $context
 * the context array passed in by trigger.module
 *
 * @param array $token_objects
 * The types that a prepared for the token replace. Generally, the represent $info->objects
 *
 * @param stdClass $activity_object
 * The activity object from the activity_info() hook 
 *
 * @return boolean
 * whether or not to record this trigger
 *
 * @see:
 * activity_get_module_info()
 */
function activity_record_check($object, $context, $token_objects, $activity_object) {
  global $user;
  // Compare the user settings with the $context[hook] and [op] and if the user
  // has opted out do not record, just return
  $hook_op = $context['hook'] .'_'. $context['op'];
  if (isset($user->activity_ignore[$hook_op]) && $user->activity_ignore[$hook_op] == 0) {
    // user has opted out of this particular action
    return FALSE;
  }
  // Checkboxes says 'story' => 0 when story wasn't checked so we need to process here
  $types = array();
  if (isset($context['activity_types'])) {
    foreach ($context['activity_types'] as $type => $value) {
      if (!empty($value)) {
        $types[] = $type;
      }
    }
  }
  
  if (!empty($types)) {
    return module_invoke($activity_object->name, 'activity_type_check', $token_objects, $types);
  }
  
  return TRUE;
}

/**
 * Implementation of a configurable Drupal action.
 * Tokenize and record an activity message.
 *
 * @param $object
 * @param $context
 *	 Holds ['hook'], ['op'], ['object'](node), ['author-pattern'],
 *   ['everyone-pattern']
 */
function activity_record($object, $context) {
  global $user;
  // find what the type is so we can do the tokenizing
  $activity_object = FALSE;
  foreach (activity_get_module_info() as $module => $info) {
    if (in_array($context['hook'], array_keys($info->hooks))) {
      // we found the activity we wanted
      $activity_object = $info;
      break;
    }
  }
  
  if (!$activity_object) {
    // not a valid trigger
    return;
  }
  
  $type = $activity_object->object_type;

  // Sometimes we need access to multiple objects. In the case of a comment, for
  // example, we need the comment, node, and user objects in order to be able to
  // do enough tokenizing. Idea appropriated from http://drupal.org/node/306324
  switch ($type) {
    case 'comment':
      // for comment, we want to add node AND user
      $types['node'] = node_load($context[$type]->nid);
    case 'node':
      // Pass in the current user. The node's author is available through the
      // [author-*] tokens.
      $types['user'] = $user;
      break;
  }
  
  // bring in all the types so that we can replace_multiple
  foreach ($activity_object->objects as $object_key) {
    if (!empty($context[$object_key])) {
      $types[$object_key] = $context[$object_key];
    }
  }
  
  // types is the array for the token replace
  // it uses key 'user' not 'account'
  if ($types['account']) {
    $types['user'] = $types['account'];
  }
  if (!isset($types[$type]) && isset($context[$type])) {
    $types[$type] = $context[$type];
  }

  // check make sure we should record this activity
  // activity trigger modules can implement the hook_activity_type_check
  // to tell activity which triggers it should ignore
  if (!activity_record_check($object, $context, $types, $activity_object)) {
    return;
  }
  // grab the targeted params
  foreach ($activity_object->objects as $object_name) {
    $patterns[$object_name] = $context["$object_name-pattern"];
  }
  
  // $messages is keyed by uid
  $messages = array();

  // foreach pattern in the context, token_replace_multiple() with types
  foreach ($patterns as $target_key => $message) {
    if (!empty($types[$target_key])) {
      $messages[intval($types[$target_key]->uid)] = token_replace_multiple($message, $types, '[', ']', array(), TRUE);
    }
  }
  
  // and now do the everyone else pattern
  $messages[0] = token_replace_multiple($context['everyone-pattern'], $types, '[', ']', array(), TRUE);

  // create a record
  $nid = NULL;
  if (isset($context['node']->nid)) {
    $nid = $context['node']->nid;
    // if the trigger op = 'presave' and you're creating a new node, $nid = null
    // because the record hasn't yet been saved to the node table
  }
  
  // NOTICE: no elseif(). This is because if the comment is part of the context
  // we want that nid as its the lowest level player. Doubt that will ever be an issue
  if (isset($context['comment']->nid)) {
    $nid = $context['comment']->nid;
  }
  
  $record = new stdClass();
  $record->uid = (!empty($context[$type]->uid)) ? $context[$type]->uid : $user->uid;
  $record->op = $context['op'];
  $record->type = $activity_object->name;
  $record->nid = $nid;
  $record->created = time(); // for PHP4 compat. for D7 use REQUEST_TIME

  // allow other modules to manipulate the record before insertion
  drupal_alter('activity_record', $record, $context);
  drupal_write_record('activity', $record);
  
  // allow other modules to change the messages based on the activity type
  drupal_alter('activity_messages', $messages, $type);
  
  // write the messages here
  foreach ($messages as $uid => $message) {
    // write the message away first so we have the amid
    $message_record = new stdClass();
    $message_record->message = $message;
    drupal_write_record('activity_messages', $message_record);
    
    // now save the target with the amid from above ^^
    $target_record = new stdClass();
    $target_record->aid = $record->aid;
    $target_record->uid = $uid;
    $target_record->amid = $message_record->amid;
    drupal_write_record('activity_targets', $target_record);
  }
  
  // after this is recorded, another module might want the aid
  module_invoke_all('activity_message_recorded', $record, $context);
  
  // collect all the grants and filter out the grants that are ignored
  // @see activity_settings_form()
  // while activity_get_grants does a rough job of this by only calling modules
  // that provide the allowed realms, it doesn't filter the extra out
  // so we do that here
  $grants = activity_get_grants($record, $context[$type], $type);
  $keep_keys = array_diff(array_keys($grants), variable_get('activity_access_realms', array('comment')));
  
  // remove the bad realms
  if (!empty($keep_keys)) {
    foreach ($grants as $realm => $data) {
      if (in_array($realm, $keep_keys)) {
        unset($grants[$realm]);
      }
    }
  }

  // allow other modules to override what is recorded
  drupal_alter('activity_access_records', $grants, $context);
  
  foreach ($grants as $realm => $values) {
    foreach ($values as $value) {
      // insert one by one. In D7 we can use the DBTNG to insert multiple
      $perm = new stdClass();
      $perm->aid = $record->aid;
      $perm->realm = $realm;
      $perm->value = $value;
      drupal_write_record('activity_access', $perm);
    }
  }
}

/**
 * return all the grants for a given activity
 *
 * @param stdClass $record
 * the database record for the activity table
 *
 * @param mixed $object
 * The object for which this activity fired for
 *
 * @param string $type
 * the activity type
 *
 * @return array
 * The grant records for this activity
 * 
 */
function activity_get_grants($record, $object, $type) {
  // load up any files that need to be loaded
  $api_info = activity_get_module_info();
  $allowed_realms = variable_get('activity_access_realms', array('comment'));
  $modules = array();
  foreach ($api_info as $module => $info) {
   
    // only include the file if it provides an allowed realm
    if (count(array_intersect(array_keys($info->realms), $allowed_realms))) {
      $modules[] = $module;
    }
  }

  $grants = array();
  // get the grants for this activity
  // call only the modules that provide the allowed realms
  // This doesn't not guantree what we want though. Additional filtering
  // still needs to happen and does
  // @see activity_record
  foreach ($modules as $module) {
    $grants = array_merge_recursive($grants, module_invoke($module, 'activity_grants', $record, $object, $type));
  }

  return $grants;
}

/**
 * Delete an activity message.
 *
 * @param int $aid
 *   The activity message id for the activity message table.
 */
function activity_delete($aid) {
  // This is MySQL specific multitable delete
  db_query("DELETE m, at, aa, a FROM {activity} a
           LEFT JOIN {activity_access} aa ON aa.aid = a.aid
           INNER JOIN {activity_targets} at ON at.aid = a.aid
           INNER JOIN {activity_messages} m ON m.amid = at.amid
           WHERE a.aid = %d", $aid
  );
}

/**
 * Implementation of hook_db_rewrite_sql().
 */
function activity_db_rewrite_sql($query, $primary_table, $primary_field, $args) {
  if ($primary_field == 'aid' && count(module_implements('node_grants'))) {
    // add in node_access stuff here
    $node_access = _node_access_where_sql();
    if (!empty($node_access)) {
      $return['join'] = " LEFT JOIN {node_access} na ON na.nid = $primary_table.nid";
      $return['where'] = "($primary_table.nid IS NULL OR (" . $node_access . "))";
    }
    return $return;
  }
}

/**
 * Implementation of hook_views_api().
 */
function activity_views_api() {
  return array(
    'api' => 2.0,
    'path' => drupal_get_path('module', 'activity') . '/views',
  );
}

/**
 * Implementation of hook_cron().
 */
function activity_cron() {
  // default is 2 weeks 1209600
  $expire = variable_get('activity_expire', 0);
  if ($expire) {
    db_query("DELETE m, at, aa, a FROM {activity} a
             LEFT JOIN {activity_access} aa ON aa.aid = a.aid
             INNER JOIN {activity_targets} at ON at.aid = a.aid
             INNER JOIN {activity_messages} m ON m.amid = at.amid
             WHERE a.created < %d", $_SERVER['REQUEST_TIME'] - $expire
    );
  }
  $expire = variable_get('activity_count_expire', 0);
  if ($expire) {
    // set the variables
    db_query("SET @current_uid := -1");
    db_query("SET @uid_position := 1");
    
    // Order bys need to be in same direction so that MySQL uses the indices
    db_query_temporary("SELECT aid, IF (@current_uid = uid, @uid_position := @uid_position+1, @uid_position := 1) as spot, IF (@current_uid <> uid, @current_uid := uid, @current_uid) as activity_uid from activity ORDER BY uid ASC, created ASC", "activity_stats");

    db_query("DELETE m, at, aa, a FROM {activity} a
             LEFT JOIN {activity_access} aa ON aa.aid = a.aid
             INNER JOIN {activity_targets} at ON at.aid = a.aid
             INNER JOIN {activity_messages} m ON m.amid = at.amid
             INNER JOIN {activity_stats} stat ON stat.aid = a.aid AND stat.spot > %d",
      $expire
    );
  }
}

/**
 * Implementation of hook_theme().
 */
function activity_theme($existing, $type, $theme, $path) {
  return array(
    'activity_settings_actions_list' => array(
      'arguments' => array('results' => NULL),
    ),
    'activity_token_help' => array(
      'arguments' => array('types' => NULL, 'prefix' => NULL, 'suffix' => NULL),
    ),
    'activity_username' => array(
      'arguments' => array('account' => NULL),
    ),
  );
}

/**
 * Theme function to display a list of available activity actions.
 */
function theme_activity_settings_actions_list($results) {
  $header = array(t('Module'), t('Trigger'), t('Operations'));
  foreach ($results as $result) {
    $rows[] = array(
      drupal_ucfirst(str_replace('_', ' ', $result['hook'])),
      $result['description'],
      l('configure', 'admin/settings/activity/configure/'. $result['aid']) .' | '.
      l('delete', 'admin/settings/activity/delete/'. $result['aid']),
    );
  }
  $output = theme('table', $header, $rows);
  return $output;
}

/**
 *
 * This is a replacement for Token's theme_token_help().
 *
 * This is a duplicate of the Token's function, but with a small modification:
 * the $type parameter is now $types, allowing for listing tokens from several
 * categories.
 */
function theme_activity_token_help($types = array('all'), $prefix = '[', $suffix = ']') {
  token_include();
  if (in_array('account', $types)) {
    // so we bring in the user tokens as well
    $types[] = 'user';
  }

  // Sometimes we need access to multiple objects. In the case of a comment, for
  // example, we need the comment, node, and user objects in order to be able to
  // do enough tokenizing. Idea appropriated from http://drupal.org/node/306324
  if (in_array('comment', $types)) {
    $types[] = 'node';
  }
  if (in_array('node', $types)) {
    $types[] = 'user';
  }

  $tokens = activity_token_get_list($types);

  $headers = array(t('Token'), t('Replacement value'));
  foreach ($tokens as $key => $category) {
    $rows = array();
    //$rows[] = array(array('data' => drupal_ucfirst($key) . ' ' . t('tokens'), 'class' => 'region', 'colspan' => 2));
    $form[$key] = array(
      '#type' => 'fieldset',
      '#title' => drupal_ucfirst($key),
      '#collapsible' => TRUE,
      '#collapsed' => TRUE,
    );
    foreach ($category as $token => $description) {
      $row = array();
      $row[] = $prefix . $token . $suffix;
      $row[] = $description;
      $rows[] = $row;
    }
    $form[$key]['tokens'] = array(
      '#type' => 'markup',
      '#value' => theme('table', $headers, $rows, array('class' => 'description')),
    );
  }
  
  return drupal_render($form);
}

/**
 * Theme function to return username.
 * This allows us to theme the username separately for activity feeds then the
 * rest of the site.
 */
function theme_activity_username($account) {
  return theme('username', $account);
}
